<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>golang 的 interface(第一篇) - 接口的定义与实现 | Chyroc的博客</title><link rel=stylesheet href=/css/style.css><link href=//cdn.bootcss.com/highlight.js/9.12.0/styles/github.min.css rel=stylesheet></head><body><nav><ul class=menu><li><a href=/>主页</a></li><li><a href=/blogroll/>友链</a></li><li><a href=/about/>关于</a></li></ul><hr></nav><div class=article-meta><h1><span class=title>golang 的 interface(第一篇) - 接口的定义与实现</span></h1><h2 class=date>2017/08/03</h2></div><main><h2 id=golang-有哪些数据类型>golang 有哪些数据类型</h2><p>interface 是一种数据类型吗，答案是：是。</p><p>golang 语言有四种数据类型，分别是
- 基本类型(basic)
- 数字
- 字符串
- 布尔型
- 聚合类型(aggregate)
- <strong>数组</strong>
- struct
- 复合类型(reference)
- 指针
- <strong>slice</strong>
- map
- 函数
- channel
- 接口类型(interface)</p><h2 id=什么是方法>什么是方法</h2><p>方法是定义在一个数据类型上面的函数，可以类比为 “面向对象中，类中的方法”。</p><p>方法和这个数据类型需要处于同一个包里，所以对于内置类型，如 int，需要从他定义一个数据类型，</p><pre><code class=language-go>type CountNum int
</code></pre><p>然后再在这个新的数据类型上定义方法</p><pre><code class=language-go>func (c CountNum) Print {
    fmt.Printf(&quot;CountNum is %d&quot;, i)
}
</code></pre><p>最常用的就是在 struct 上定义方法</p><pre><code class=language-go>type Person struct {
	Name string
	Age int
}

func (p Person) Get {
  return fmt.Sprintf(&quot;Person name: %6s, age: %4d&quot;, p.Name, p.Age)
}
</code></pre><p>使用方法修改所定义的数据类型的数据</p><pre><code class=language-go>func (p Person) Set(name string) {
	p.Name = name
}
</code></pre><p>如果直接这么写，是有问题的。</p><p>因为在 golang 中是参数是值传递，所以在上面这个方法里，收到了类型为<code>Person</code>的一个值的拷贝<code>p</code>，然后对<code>p</code>做了修改，是无法传递出去的。</p><p>所以需要改为传递指针变量：</p><pre><code class=language-go>func (p *Person) Set(name string) {
	p.Name = name
}
</code></pre><p>这样就可以通过指针修改原来的数据。</p><p>事实上，指针仍然是值传递，但是，哈哈，拷贝的指针指向的地方是不变的，是依然可以修改的。</p><h2 id=怎么定义一个-interface>怎么定义一个 interface</h2><p>划重点：<strong>接口的定义是方法的声明的集合，接口的实现是方法的实现的集合</strong></p><p>所以我刚刚先说了方法。</p><p>和方法不一样的是，接口并不是定义在具体的类型上面的（方法是这样的）。</p><p>同一个接口可以在不同数据类型上实现，取决于你想要怎么搞了。</p><p>这里我先定义一个接口：</p><pre><code class=language-go>type GetSet interface {
    Get() string
    Set(string)
}
</code></pre><p>这个接口声明了两个方法：<code>Get() string</code>,<code>Set(string)</code>，这两个方法合起来(<code>interface{ }</code>)就构成了一个接口，这个接口的名字叫做<code>GetSet</code>。</p><h2 id=怎么实现一个-interface>怎么实现一个 interface</h2><h4 id=说明>说明</h4><p>golang 这门语言的接口与其他语言的不同之处在于，golang 的接口是<code>隐式实现</code>的。</p><p>这是什么意思呢？</p><p>意思就是你不需要<code>显式</code>的这么做：</p><pre><code class=language-java>class SomeClass implements SomeInterface {

}
</code></pre><h4 id=那怎么做>那怎么做</h4><p>刚刚说了：「接口的实现是方法的实现的集合」，方法是定义在数据类型上面的，所以先给出一个数据类型：</p><pre><code class=language-go>type Person struct {
	Name string
	Age  int
}
</code></pre><p>然后对这个数据类型实现接口定义里面所有声明的方法，也就是：<code>Get() string</code>,<code>Set(string)</code></p><pre><code class=language-go>func (p *Person) Get() string {
	return fmt.Sprintf(&quot;Person name: %6s, age: %4d&quot;, p.Name, p.Age)
}

func (p *Person) Set(name string) {
	p.Name = name
}
</code></pre><h4 id=断言是否实现了接口>断言是否实现了接口</h4><p>ok，到这里为止，我定义了一个接口<code>GetSet</code>，然后用<code>Person</code>实现了这个接口，一切都很美好，问题是，我真的实现了这个接口了吗？</p><p>有一个简单的方法去判断：</p><pre><code class=language-go>var _ GetSet = new(Person) // var _ GetSet = Person{}
</code></pre><p>这是一个断言：<code>Person</code>的一个值实现了接口<code>GetSet</code>，如果<code>Person</code>没有实现了接口<code>GetSet</code>，编译的时候就会报错。</p><p>实际上，我们不需要创建一个变量（<code>new(Person)</code>），因为<code>Person</code>是任意值都实现了这个接口，所以<code>nil</code>也实现了，所以可以用类型转化做断言，代码如下：</p><pre><code class=language-go>var _ GetSet = (*Person)(nil)
</code></pre><h2 id=空-interface-是什么>空 interface 是什么</h2><p>什么是空接口：</p><pre><code class=language-go>interface{}
</code></pre><p>上面说过，接口是声明的方法的集合，空接口没有声明方法，所以任何类型都实现了空接口。</p><p>所以一个函数可以使用<code>interface{}</code>接受任意类型的值作为参数，也可以使用<code>interface{}</code>将任意类型的值作为返回值。</p></main><footer><script async src="//cdn.bootcss.com/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML"></script><script src=../../js/jquery-3.3.1.min.js></script><script src=../../js/code.js></script><script src=../../css/highlight.css></script><script src=../../js/instantclick.min.js data-no-instant></script><script data-no-instant>InstantClick.init();</script><script>hljs.configure({languages:[]});hljs.initHighlightingOnLoad();</script><hr>&copy; <a href=https://chyroc.cn>chyroc</a> <a href=https://themes.gohugo.io/hugo-xmin/>Theme By hyde</a> 2021
<span id=reading-statistics><span></footer><div id=git-comments></div><link rel=stylesheet href=https://imsun.github.io/gitment/style/default.css><script src=https://imsun.github.io/gitment/dist/gitment.browser.js></script><script>var gitment=new Gitment({id:'golang-interface-i',title:'golang 的 interface(第一篇) - 接口的定义与实现',owner:'Chyroc',repo:'chyroc.github.io',oauth:{client_id:'36628d87f0ace3c0f34c',client_secret:'814e29f878a31ddf2a0f8f010c2bc3615750a998',}})
gitment.render('git-comments')</script></body></html>