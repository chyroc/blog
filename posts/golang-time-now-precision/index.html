<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>golang 的 time.Now 精度 | Chyroc的博客</title><link rel=stylesheet href=/css/style.css><link href=//cdn.bootcss.com/highlight.js/9.12.0/styles/github.min.css rel=stylesheet></head><body><nav><ul class=menu><li><a href=/>主页</a></li><li><a href=/blogroll/>友链</a></li><li><a href=/about/>关于</a></li></ul><hr></nav><div class=article-meta><h1><span class=title>golang 的 time.Now 精度</span></h1><h2 class=date>2019/03/03</h2></div><main><p>昨天群里有人问了一个问题</p><blockquote><p>golang defer 函数参数是什么时候求值的哈， 我这边试了下输出有时候两者是一样的，有时候两者相差 1000ms</p></blockquote><p><img src=https://media.chyroc.cn/img/1a908e73-5b1f-4bed-a676-097a4370ef9f.png alt></p><p>这里面的 defer 的参数计算问题可以在<a href=https://chyroc.cn/posts/defer-return/>这篇文章</a>中找到</p><p>本文主要讨论 <code>time.Now</code> 函数的精度问题。</p><p>先看一下下面这段代码</p><pre><code class=language-go>package main

import (
	&quot;fmt&quot;
	&quot;time&quot;
)

func test() {
	for i := 0; i &lt;= 1000; i++ {
		start := time.Now()                                              // 1
		defer fmt.Print(time.Now().Nanosecond()-start.Nanosecond(), &quot;,&quot;) // 2
		time.Sleep(1000)                                                 // 3
	}
	fmt.Println()
}

func test2() {
	s := time.Now() //4
	N := 1000
	for i := 0; i &lt;= N; i++ {
		time.Now() // 5
	}
	fmt.Println()
	fmt.Println((time.Now().Nanosecond() - s.Nanosecond()) / (N + 1)) // 6
}

func main() {
	test()
	test2()
}
</code></pre><p><code>test</code> 函数就是截图里面那位朋友的代码。</p><p>首先，<code>line 2</code> 肯定是先计算 <code>time.Now()</code>，然后再将参数入栈的，现在的问题是：这样的代码的结果应该是固定的，为什么有时候返回 <code>0ns</code>，有时候返回 <code>1000ns</code>？</p><p>我看到这段代码后，想到的第一个原因就是 <code>time.Now</code> 这个函数的执行时间导致的上面的问题，但是仔细一想：如果是这样的话，name 应该每次相差的结果（<code>line 2</code> print 的）应该差不多呀，为什么大部分是 0，少部分是 1000 呢？而且为什么是 1000，不是 2000 呢？</p><p>然后我就翻了一下 <code>go</code> 的 <code>time.Now</code> 的源码：</p><ul><li><p><a href=https://github.com/golang/go/blob/master/src/runtime/timestub.go#L15-L18>timestub.go</a></p><pre><code class=language-go>//go:linkname time_now time.now
func time_now() (sec int64, nsec int32, mono int64) {
	sec, nsec = walltime()
	return sec, nsec, nanotime()
}
</code></pre></li><li><p><a href=https://github.com/golang/go/blob/master/src/runtime/sys_darwin.go#L248-L252>sys_darwin.go</a></p><pre><code class=language-go>//go:nosplit
//go:cgo_unsafe_args
func walltime() (int64, int32) {
	var t timeval
	libcCall(unsafe.Pointer(funcPC(walltime_trampoline)), unsafe.Pointer(&amp;t))
	return int64(t.tv_sec), 1000 * t.tv_usec  // line 7
}
</code></pre></li></ul><p>[捂脸]根据 <code>line 7</code>，在 <code>darwin(mac)</code> 系统上，go 的 <code>time.Now</code> 精度就是 1000ns。</p><p>所以在上面 <code>line 2</code> 的代码中，每个 <code>time.Now</code> 都是 80 - 150 ns 的时间，然后 print 0，到 1000 ns 过去后，就 print 一个 1000 ns</p><p>将上面的代码交叉编译并在 linux 系统上执行，结果是：</p><p><img src=https://media.chyroc.cn/img/de10cb13-6439-4225-873c-2c2fa0dc3239.png alt></p><p>嗯&hellip;是正常的了。</p></main><footer><script async src="//cdn.bootcss.com/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML"></script><script src=../../js/jquery-3.3.1.min.js></script><script src=../../js/code.js></script><script src=../../css/highlight.css></script><script src=../../js/instantclick.min.js data-no-instant></script><script data-no-instant>InstantClick.init();</script><script>hljs.configure({languages:[]});hljs.initHighlightingOnLoad();</script><hr>&copy; <a href=https://chyroc.cn>chyroc</a> <a href=https://themes.gohugo.io/hugo-xmin/>Theme By hyde</a> 2021
<span id=reading-statistics><span></footer><div id=git-comments></div><link rel=stylesheet href=https://imsun.github.io/gitment/style/default.css><script src=https://imsun.github.io/gitment/dist/gitment.browser.js></script><script>var gitment=new Gitment({id:'golang-time-now-precision',title:'golang 的 time.Now 精度',owner:'Chyroc',repo:'chyroc.github.io',oauth:{client_id:'36628d87f0ace3c0f34c',client_secret:'814e29f878a31ddf2a0f8f010c2bc3615750a998',}})
gitment.render('git-comments')</script></body></html>