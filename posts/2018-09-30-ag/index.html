<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>2018-09-30 AG | Chyroc的博客</title><link rel=stylesheet href=/css/style.css><link href=//cdn.bootcss.com/highlight.js/9.12.0/styles/github.min.css rel=stylesheet></head><body><nav><ul class=menu><li><a href=/>主页</a></li><li><a href=/blogroll/>友链</a></li><li><a href=/about/>关于</a></li></ul><hr></nav><div class=article-meta><h1><span class=title>2018-09-30 AG</span></h1><h2 class=date>2018/09/26</h2></div><main><p>每个月零零散散读了一些文章，前脚读，后脚忘，可能有些微收获，但还是感觉太过粗略，所以这里将一些读过的文章记录下来。</p><p>转瞬一想，既然可以记录文章阅读感想，何不也记录一下其他的一些东西，列如 bug 啦，算法啦，github 项目啦等等之类的事情呢？</p><p>所以有这个 ag，大概一周一次吧（可能以后这个 ag 会扩展）</p><ul><li>a article 文章</li><li>g github 相关的项目</li></ul><h1 id=文章>文章</h1><h2 id=阿里如何实现-100-容器化镜像化-八年技术演进之路回顾-https-mp-weixin-qq-com-s-suowvlp9iathphvouv9oea><a href=https://mp.weixin.qq.com/s/suoWVlp9iaTHPhvOUV9oEA>阿里如何实现 100%容器化镜像化？八年技术演进之路回顾</a></h2><blockquote><p>阿里 2011 年的时候搞了一个 T4，15 年的时候引入 docker 的镜像机制（即将应用运行的环境一并打包），18 年开源了 PouchContainer
总的来说就是一个阿里的容器化演变的过程，有些段落有些重复
提问里面说的跨部门和跨子公司如何推广确实是一个好问题</p></blockquote><h2 id=聊聊-redis-性能细节-https-mp-weixin-qq-com-s-8quzl-s-zq-3usrsqww5a><a href=https://mp.weixin.qq.com/s/8QUZl_S-_zq_3usRsQWW5A>聊聊 Redis 性能细节</a></h2><blockquote><p>使用一个软件，如果在高并发高流量的情况下，需要知道一些底层软件的原理，不能完全当一个黑盒使用
少用 hash，少存储大数据，避免影响其他业务
使用配置中心，实现秒级降级</p></blockquote><h2 id=go-并发编程-goroutine-如何调度的-https-mp-weixin-qq-com-s-edpnour1ukusv39jde-w4a><a href=https://mp.weixin.qq.com/s/eDpNOUR1uKUsV39jDe_w4A>Go 并发编程-Goroutine 如何调度的</a></h2><blockquote><p>注：这个文章被删除了</p></blockquote><p>并发: 逻辑上具有处理多个同时性任务的能力
并行: 物理上同一时刻执行多个并发任务</p><p>goroutine 说是协程不太恰当，因为 goroutine 是被多个线程调度执行的</p><h3 id=go-调度器组成>Go 调度器组成</h3><p>Go 语言虽然使用一个 Go 关键字即可实现并发编程，但 Goroutine 被调度到后端之后，具体的实现比较复杂。先看看调度器有哪几部分组成。</p><p>1、G</p><p>G 是 Goroutine 的缩写，相当于操作系统中的进程控制块，在这里就是 Goroutine 的控制结构，是对 Goroutine 的抽象。其中包括执行的函数指令及参数；G 保存的任务对象；线程上下文切换，现场保护和现场恢复需要的寄存器(SP、IP)等信息。</p><p>Go 不同版本 Goroutine 默认栈大小不同。</p><p>2、M</p><p>M 是一个线程或称为 Machine，所有 M 是有线程栈的。如果不对该线程栈提供内存的话，系统会给该线程栈提供内存(不同操作系统提供的线程栈大小不同)。当指定了线程栈，则 M.stack→G.stack，M 的 PC 寄存器指向 G 提供的函数，然后去执行。</p><p>3、P</p><p>P(Processor)是一个抽象的概念，并不是真正的物理 CPU。所以当 P 有任务时需要创建或者唤醒一个系统线程来执行它队列里的任务。所以 P/M 需要进行绑定，构成一个执行单元。</p><p>P 决定了同时可以并发任务的数量，可通过 GOMAXPROCS 限制同时执行用户级任务的操作系统线程。可以通过 runtime.GOMAXPROCS 进行指定。在 Go1.5 之后 GOMAXPROCS 被默认设置可用的核数，而之前则默认为 1。</p><h3 id=go-调度器调度过程>Go 调度器调度过程</h3><p><img src=https://media.chyroc.cn/img/go-gpm.webp alt></p><p>首先创建一个 G 对象，G 对象保存到 P 本地队列或者是全局队列。P 此时去唤醒一个 M。P 继续执行它的执行序。M 寻找是否有空闲的 P，如果有则将该 G 对象移动到它本身。接下来 M 执行一个调度循环(调用 G 对象-&gt;执行-&gt;清理线程→继续找新的 Goroutine 执行)。</p><p>M 执行过程中，随时会发生上下文切换。当发生上线文切换时，需要对执行现场进行保护，以便下次被调度执行时进行现场恢复。Go 调度器 M 的栈保存在 G 对象上，只需要将 M 所需要的寄存器(SP、PC 等)保存到 G 对象上就可以实现现场保护。当这些寄存器数据被保护起来，就随时可以做上下文切换了，在中断之前把现场保存起来。如果此时 G 任务还没有执行完，M 可以将任务重新丢到 P 的任务队列，等待下一次被调度执行。当再次被调度执行时，M 通过访问 G 的 vdsoSP、vdsoPC 寄存器进行现场恢复(从上次中断位置继续执行)。</p><p>1、P 队列
通过上图可以发现，P 有两种队列：本地队列和全局队列。</p><ul><li>本地队列： 当前 P 的队列，本地队列是 Lock-Free，没有数据竞争问题，无需加锁处理，可以提升处理速度。</li><li>全局队列：全局队列为了保证多个 P 之间任务的平衡。所有 M 共享 P 全局队列，为保证数据竞争问题，需要加锁处理。相比本地队列处理速度要低于全局队列。</li></ul><p>2、上线文切换</p><p>简单理解为当时的环境即可，环境可以包括当时程序状态以及变量状态。例如线程切换的时候在内核会发生上下文切换，这里的上下文就包括了当时寄存器的值，把寄存器的值保存起来，等下次该线程又得到 cpu 时间的时候再恢复寄存器的值，这样线程才能正确运行。</p><p>对于代码中某个值说，上下文是指这个值所在的局部(全局)作用域对象。相对于进程而言，上下文就是进程执行时的环境，具体来说就是各个变量和数据，包括所有的寄存器变量、进程打开的文件、内存(堆栈)信息等。</p><p>3、线程清理
Goroutine 被调度执行必须保证 P/M 进行绑定，所以线程清理只需要将 P 释放就可以实现线程的清理。什么时候 P 会释放，保证其它 G 可以被执行。P 被释放主要有两种情况。</p><ul><li>主动释放：最典型的例子是，当执行 G 任务时有系统调用，当发生系统调用时 M 会处于 Block 状态。调度器会设置一个超时时间，当超时时会将 P 释放。</li><li>被动释放：如果发生系统调用，有一个专门监控程序，进行扫描当前处于阻塞的 P/M 组合。当超过系统程序设置的超时时间，会自动将 P 资源抢走。去执行队列的其它 G 任务。</li></ul><h2 id=想养只猫-和菜头-https-mp-weixin-qq-com-s-hi7kn-wv4n-zchvwofxwmq><a href=https://mp.weixin.qq.com/s/hI7kn-wv4N-zcHVwofxwMQ>想养只猫 - 和菜头</a></h2><blockquote><p>给焦虑的生活带来一点点平静</p></blockquote><h2 id=浅谈-docker-的安全性支持-上篇-https-mp-weixin-qq-com-s-lxhbic5sm4ki4pozwzi7pa><a href=https://mp.weixin.qq.com/s/lxHBic5sm4KI4poZWZI7pA>浅谈 Docker 的安全性支持（上篇）</a></h2><blockquote><p>docker 对于镜像内的系统做了一些安全方面的限制</p></blockquote><h2 id=golang-json-的进阶用法-https-mp-weixin-qq-com-s-zyyod4mmml5im09teqss0g><a href=https://mp.weixin.qq.com/s/ZyyOD4mMML5Im09tEQss0g>Golang json 的进阶用法</a></h2><blockquote><p>go 在解析 json 的时候，如果不确定一个字段的类型（如 port 是 string 还是 int），可以定义一个新类型，然后实现接口：<code>json.Unmarshaller interface</code> / <code>json.Marshaller interface</code>，就可以将两个类型都 hold 住</p></blockquote><h2 id=go-101-https-go101-org-article-101-html><a href=https://go101.org/article/101.html>go 101</a></h2><blockquote><p>有关 go 的一些 tips 知识点，挺好的，回头专门写个读后感</p></blockquote><h2 id=如何降低软件的复杂性-阮一峰-http-www-ruanyifeng-com-blog-2018-09-complexity-html><a href=http://www.ruanyifeng.com/blog/2018/09/complexity.html>如何降低软件的复杂性？ - 阮一峰</a></h2><blockquote><p>这篇文章是阮一峰看斯坦福大学计算机系教授 John Ousterhout 在谷歌的一次演讲（<a href="https://www.youtube.com/watch?v=bmSAYlu0NcY">Youtube</a>）和网上对该教授的一本新书《软件设计的哲学》（<a href=https://www.amazon.com/Philosophy-Software-Design-John-Ousterhout/dp/1732102201>A Philosophy of Software Design</a>）的<a href=https://lethain.com/notes-philosophy-software-design/>书评</a>的笔记
减少代码含义的模糊性 / 减少代码之间的依赖
将复杂的代码扔到一个模块
好的接口应该是小接口，大功能：也就是说对外暴露的方法比较少，但是在方法的内部实现上，可以很复杂，避免对外暴露复杂的细节</p></blockquote><h1 id=github>github</h1><h3 id=https-github-com-antlr-grammars-v4><a href=https://github.com/antlr/grammars-v4>https://github.com/antlr/grammars-v4</a></h3><blockquote><p>使用 ANTLR v4 语法写的各个语言的语法</p></blockquote><h3 id=https-github-com-kocircuit-kocircuit><a href=https://github.com/kocircuit/kocircuit>https://github.com/kocircuit/kocircuit</a></h3><blockquote><p>一个用 go 实现的并发的，general 的但是类型安全的，函数式的语言
感觉比 anko 厉害点</p></blockquote><h3 id=https-github-com-tencent-vconsole><a href=https://github.com/Tencent/vConsole>https://github.com/Tencent/vConsole</a></h3><blockquote><p>一个手机网页端的类似 chrome 控制台 console 的 console</p></blockquote><h3 id=https-github-com-dawnlabs-carbon><a href=https://github.com/dawnlabs/carbon>https://github.com/dawnlabs/carbon</a></h3><blockquote><p>一个将代码生成美丽图片的工具</p></blockquote><h3 id=https-github-com-go101-go101><a href=https://github.com/go101/go101>https://github.com/go101/go101</a></h3><blockquote><p>go 101 的 github 源码</p></blockquote></main><footer><script async src="//cdn.bootcss.com/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML"></script><script src=../../js/jquery-3.3.1.min.js></script><script src=../../js/code.js></script><script src=../../css/highlight.css></script><script src=../../js/instantclick.min.js data-no-instant></script><script data-no-instant>InstantClick.init();</script><script>hljs.configure({languages:[]});hljs.initHighlightingOnLoad();</script><hr>&copy; <a href=https://chyroc.cn>chyroc</a> <a href=https://themes.gohugo.io/hugo-xmin/>Theme By hyde</a> 2021
<span id=reading-statistics><span></footer><div id=git-comments></div><link rel=stylesheet href=https://imsun.github.io/gitment/style/default.css><script src=https://imsun.github.io/gitment/dist/gitment.browser.js></script><script>var gitment=new Gitment({id:'2018-09-30-ag',title:'2018-09-30 AG',owner:'Chyroc',repo:'chyroc.github.io',oauth:{client_id:'36628d87f0ace3c0f34c',client_secret:'814e29f878a31ddf2a0f8f010c2bc3615750a998',}})
gitment.render('git-comments')</script></body></html>