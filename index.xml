<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Chyroc的博客</title><link>https://chyroc.cn/</link><description>Recent content on Chyroc的博客</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Thu, 23 Apr 2020 17:14:04 +0000</lastBuildDate><atom:link href="https://chyroc.cn/index.xml" rel="self" type="application/rss+xml"/><item><title>使用 Alfred 搜索 YAPI 接口</title><link>https://chyroc.cn/posts/2020.04.24-alfread-wf-yapi/</link><pubDate>Thu, 23 Apr 2020 17:14:04 +0000</pubDate><guid>https://chyroc.cn/posts/2020.04.24-alfread-wf-yapi/</guid><description>使用 Alfred 搜索 YAPI 接口 1</description></item><item><title>bigqueue 源码阅读</title><link>https://chyroc.cn/posts/source-read-bigqueue/</link><pubDate>Mon, 18 Mar 2019 18:28:08 +0800</pubDate><guid>https://chyroc.cn/posts/source-read-bigqueue/</guid><description>grandecola/bigqueue 源码阅读 依赖 grandecola/mmap 也是 bigqueue 作者写的一个 mmap 的 go 实现。
在博客 tiedot 阅读笔记（一） 里面，tidot 也是使用了一个 go 实现的 mmap 库，不过 tiedot 用的是 edsrzf/mmap-go。
文件和数据结构 bigqueue 的数据都是存在文件中的，具体如下：
所有的文件都是在一个文件夹中 这个文件在创建 BigQueue 对象的时候指定 NewBigQueue(path) 文件类型只有两种 文件 index.dat 存储 5 个数据（共 40bytes） 第一个 8 字节存储第一个数据块所在的文件 id 第二个 8 字节存储第一个数据块在文件中的 offset 第三个 8 字节存储最后一个数据块所在的文件 id 第四个 8 字节存储最后一个数据块在文件中的 offset 第五个 8 字节存储的是单个文件的大小（数据文件，默认 128M，可以通过配置修改） 文件 arena_.</description></item><item><title>每周分享 - 10</title><link>https://chyroc.cn/posts/weekly-share-10/</link><pubDate>Fri, 08 Mar 2019 11:44:18 +0800</pubDate><guid>https://chyroc.cn/posts/weekly-share-10/</guid><description>Article 文章 https://golangweekly.com/issues/252 golangweekly，阅读记录补充在本文中
https://ieftimov.com/when-why-least-frequently-used-cache-implementation-golang 缓存最重要的两个问题：
确保大部分访问能够命中 查找和更新数据的足够快 介绍了一个 O(1) LFU 算法，而不是传统的 min-heap 算法
参考： http://dhruvbird.com/lfu.pdf
GitHub 项目 https://github.com/davidbanham/human_duration golang 写的一个格式化 duration 为字符串的库，看了一下，写的还是比较简单的。提供了一个想法，但是没使用的兴趣。
https://github.com/xujiajun/nutsdb 一个中国人写的纯 go 的内嵌式的数据库（觉得 bolt 的写性能低所以重写了一个）..
https://github.com/faiface/beep go 实现的播放音频的库
https://github.com/joho/godotenv 将 k=v 存储在 .env 文件中，然后本库会将他们设置为环境变量，同时可以使用 os.LookUp 去使用变量</description></item><item><title>golang 的 time.Now 精度</title><link>https://chyroc.cn/posts/golang-time-now-precision/</link><pubDate>Sun, 03 Mar 2019 14:08:25 +0800</pubDate><guid>https://chyroc.cn/posts/golang-time-now-precision/</guid><description>昨天群里有人问了一个问题
golang defer 函数参数是什么时候求值的哈， 我这边试了下输出有时候两者是一样的，有时候两者相差 1000ms
这里面的 defer 的参数计算问题可以在这篇文章中找到
本文主要讨论 time.Now 函数的精度问题。
先看一下下面这段代码
package main import ( &amp;quot;fmt&amp;quot; &amp;quot;time&amp;quot; ) func test() { for i := 0; i &amp;lt;= 1000; i++ { start := time.Now() // 1 defer fmt.Print(time.Now().Nanosecond()-start.Nanosecond(), &amp;quot;,&amp;quot;) // 2 time.Sleep(1000) // 3 } fmt.Println() } func test2() { s := time.Now() //4 N := 1000 for i := 0; i &amp;lt;= N; i++ { time.Now() // 5 } fmt.</description></item><item><title>uber-zap 源码阅读</title><link>https://chyroc.cn/posts/source-code-uber-zap/</link><pubDate>Mon, 15 Oct 2018 20:04:11 +0800</pubDate><guid>https://chyroc.cn/posts/source-code-uber-zap/</guid><description>zap是 Uber 开发的一个高性能、强类型、分 level 的 go 语言日志库。
阅读笔记：https://github.com/Chyroc/zap/pull/1/files
为了实现她的高性能，zap 做了这些优化
不使用encoding/json和fmt.Fprintf，这些都会使用 reflect，比较慢 自定义Buffer结构，代替 build-in 的bytes.Buffer 大量使用sync.Pool buffer package type Buffer struct { bs []byte pool Pool } 在Buffer上定义各个类型数据的 append
使用 sync.Pool 复用可能的对象，[]byte的初始大小为_size（1024），对一些小对象，能够避免 alloc
func NewPool() Pool { return Pool{p: &amp;amp;sync.Pool{ New: func() interface{} { return &amp;amp;Buffer{bs: make([]byte, 0, _size)} }, }} } 打印带有颜色文字 const ( Black = iota + 30 Red Green Yellow Blue Magenta Cyan White ) fmt.</description></item><item><title>2018-09-30 AG</title><link>https://chyroc.cn/posts/2018-09-30-ag/</link><pubDate>Wed, 26 Sep 2018 13:30:20 +0800</pubDate><guid>https://chyroc.cn/posts/2018-09-30-ag/</guid><description>每个月零零散散读了一些文章，前脚读，后脚忘，可能有些微收获，但还是感觉太过粗略，所以这里将一些读过的文章记录下来。
转瞬一想，既然可以记录文章阅读感想，何不也记录一下其他的一些东西，列如 bug 啦，算法啦，github 项目啦等等之类的事情呢？
所以有这个 ag，大概一周一次吧（可能以后这个 ag 会扩展）
a article 文章 g github 相关的项目 文章 阿里如何实现 100%容器化镜像化？八年技术演进之路回顾 阿里 2011 年的时候搞了一个 T4，15 年的时候引入 docker 的镜像机制（即将应用运行的环境一并打包），18 年开源了 PouchContainer 总的来说就是一个阿里的容器化演变的过程，有些段落有些重复 提问里面说的跨部门和跨子公司如何推广确实是一个好问题
聊聊 Redis 性能细节 使用一个软件，如果在高并发高流量的情况下，需要知道一些底层软件的原理，不能完全当一个黑盒使用 少用 hash，少存储大数据，避免影响其他业务 使用配置中心，实现秒级降级
Go 并发编程-Goroutine 如何调度的 注：这个文章被删除了
并发: 逻辑上具有处理多个同时性任务的能力 并行: 物理上同一时刻执行多个并发任务
goroutine 说是协程不太恰当，因为 goroutine 是被多个线程调度执行的
Go 调度器组成 Go 语言虽然使用一个 Go 关键字即可实现并发编程，但 Goroutine 被调度到后端之后，具体的实现比较复杂。先看看调度器有哪几部分组成。
1、G
G 是 Goroutine 的缩写，相当于操作系统中的进程控制块，在这里就是 Goroutine 的控制结构，是对 Goroutine 的抽象。其中包括执行的函数指令及参数；G 保存的任务对象；线程上下文切换，现场保护和现场恢复需要的寄存器(SP、IP)等信息。</description></item><item><title>《MySQL 技术内幕-InnoDB 存储引擎》阅读小记（一）</title><link>https://chyroc.cn/posts/innodb-storage-engine-reading-1/</link><pubDate>Wed, 05 Sep 2018 23:26:06 +0800</pubDate><guid>https://chyroc.cn/posts/innodb-storage-engine-reading-1/</guid><description>[TOC]
MySQL 体系结构 InnoDB 存储引擎 概述 从 mysql 5.5 版本开始是默认引擎 第一个完整支持 ACID 事务的 MySQL 引擎 特点：行锁设计、支持 MVCC、支持外键、提供一致性非锁定读、有效利用内存和 CPU 体系架构 后台线程 innodb 存储引擎是多线程模型，有多个不同的后台线程，负责处理不同的任务
master thread：将缓冲池的数据异步刷新到磁盘，保证数据的一致性，包括脏页的刷新、合并插入缓冲（insert buffer）、UNDO 页的回收
io thread
innodb 大量使用了 AIO(async io)处理 io 请求，极大提高了数据库的性能 io thread 的工作主要是负责这些 io 请求的回调处理 1.0 版本之前共有 4 个 io thread：write，read，insert buffer，log 1.0 之后，rread 和 write thread 分别增大到了 4 个 1.0 之后，可以分别使用 innodb_read_io_threads 和 innodb_write_io_threads 设置线程数 purge thread</description></item><item><title>《MySQL 必知必会》阅读小记</title><link>https://chyroc.cn/posts/mysql-crash-course-reading/</link><pubDate>Tue, 04 Sep 2018 14:03:12 +0800</pubDate><guid>https://chyroc.cn/posts/mysql-crash-course-reading/</guid><description>database：以有组织的方式存储数据
SQL: structured query language
一般命令 连接 mysql -uroot -h127.0.0.1 显示数据库 show databases
切换数据库 use database
显示表 show tables
显示列 show columns from table == desc table
显示创建数据库语句 show create database xx
显示创建表语句 show create table xx
显示权限 show grants
显示服务器状态 show status
简单查询 select &amp;lt;column&amp;gt; from &amp;lt;table&amp;gt; （不建议使用）使用*查询所有列 只返回不同的值 select distinct &amp;lt;column&amp;gt; from &amp;lt;table&amp;gt; 应用于所有列 select distinct &amp;lt;c1&amp;gt;, &amp;lt;c2&amp;gt; from &amp;lt;table&amp;gt; 那么 c1 和 c2 都一样，才不会查出来 限定查询的个数 limit 1返回一个 limit 20, 30 从第 20 个开始，返回 30 个 排序 默认升序(asc)，可以使用desc指定降序 可以指定多列 order by &amp;lt;c1&amp;gt;, &amp;lt;c2&amp;gt;, .</description></item><item><title>golang map 优化</title><link>https://chyroc.cn/posts/golang-map-optimization/</link><pubDate>Mon, 20 Aug 2018 10:10:52 +0800</pubDate><guid>https://chyroc.cn/posts/golang-map-optimization/</guid><description> 预设容量 减少内存拷贝和 rehash 直接存储小对象，而不是它的指针 直接在栈上而不是堆上分配内存，减少 gc 时间 空间收缩 就算把 map 的所有键都删除，分配的内存也不会收回 m = nil 或者 m = make(map[x]x) 参考 https://www.jianshu.com/p/c34e3a787de4</description></item><item><title>在 github 开启 gpg 的几个 Q&amp;A</title><link>https://chyroc.cn/posts/github-commit-with-gpg/</link><pubDate>Wed, 25 Jul 2018 16:17:51 +0800</pubDate><guid>https://chyroc.cn/posts/github-commit-with-gpg/</guid><description>本文不是解释 gpg 和解释 github 如何开启 gpg 的文章，仅仅记录一下我在 github 开启 gpg 的几个 Q&amp;amp;A
如何查看、备份与删除秘钥 查看 ➜ gpg --list-keys /Users/chyroc/.gnupg/pubring.kbx -------------------------------- pub rsa2048 2018-07-25 [SC] [有效至：2020-07-24] &amp;lt;gpg id&amp;gt; uid [ 绝对 ] Chyroc &amp;lt;xxxx@xxxx.com&amp;gt; sub rsa2048 2018-07-25 [E] [有效至：2020-07-24] 备份 github 现在不支持@foxmail.com邮箱，导致 github 不再支持我以前生成的 gpg 秘钥，所以我需要重新生成一个秘钥。
但是现在这个秘钥我已经在 pypi 中使用了，所以我需要先备份秘钥，然后再删除。
执行下面这个命令将秘钥导出到文件
gpg -o pri_key.gpg --export-secret-keys &amp;lt;gpg id&amp;gt; gpg -o pub_key.gpg --export &amp;lt;gpg id&amp;gt; 删除 再执行下面两个命令删除
gpg --delete-secret-keys &amp;lt;gpg id&amp;gt; gpg --delete-keys &amp;lt;gpg id&amp;gt; 如何在 github 开启 gpg 生成公钥 gpg --armor --export &amp;lt;gpg id&amp;gt; 然后将生成的公钥上传到 https://github.</description></item><item><title>poll、select 和 epoll</title><link>https://chyroc.cn/posts/poll-select-epoll/</link><pubDate>Mon, 23 Jul 2018 16:26:53 +0800</pubDate><guid>https://chyroc.cn/posts/poll-select-epoll/</guid><description>在一个 web server 程序中，我们需要读取 client 请求的输入，并且需要将服务端的数据返回给 client。在 linux（Unix）系统中，任何资源都是文件，即 fd（文件描述符），所以我们需要监控需要的 fd，以便可读时，读取 client 的输入，可写时，向 client 返回服务端的数据。
假设程序有 100 个 client 访问，那么就需要从 100 个 fd 中读取数据，那么怎么做呢？
可以为每一个 client 生成一个 thred 或者 process（线程或者进程）来处理请求，但是很显然当 client 越来越大的时候，就会非常消耗资源，因为（？？？）
select &amp;amp; poll 这两种方法是任何 Unix 系统都有的，epoll 只有 linux 有，他们的工作方式都是：
告诉他们你想要你知道哪些 fd 的信息 然后他们会在这些 fd 可读/可写的时候通知你 select 和 poll 的定义
here’s the definition of the select syscall and do_select and the definition of the poll syscall and do_poll poll 返回了很多可能的 fd 处理结果，而 select 只返回了输入/输出/错误（select 内部做了转换）</description></item><item><title>修改 github page 绑定的 cname 记录</title><link>https://chyroc.cn/posts/modify-github-page-binding-cname-record/</link><pubDate>Tue, 26 Jun 2018 19:02:37 +0800</pubDate><guid>https://chyroc.cn/posts/modify-github-page-binding-cname-record/</guid><description>原来我的 github page 绑定的域名是 blog.chyroc.cn，然后我那个repo是我的博客项目，这个本来是没有什么问题的。
但是如果你其他的项目也开启了 github page 服务，比如项目https://github.com/Chyroc/golang-wasm-example ，这个项目开启 github page 后，访问的地址是 https://blog.chyroc.cn/golang-wasm-example ，一个和 blog 没啥关系的项目的访问链接里面带了 blog，这样就比较奇怪。
所以我准备将我的 github page 绑定的域名从 blog.chyroc.cn 改为 chyroc.cn。
第一步，修改 github repo 的 CNAME 记录 commit：https://github.com/Chyroc/chyroc.github.io/commit/b253413fa3d64b4f9408ebe1100fcf79faa9d883
-blog.chyroc.cn +chyroc.cn 第二步，修改域名解析记录 移除原来的主机类型为@的 A 记录 移除原来指向 chyroc.github.io 的主机类型为blog的 CNAME 记录 添加主机类型为@的指向 github page ip 的 A 记录（可选 ip 在这里有记录：我用的是 185.199.108.153） 第三步，修改服务器 nginx 配置 移除 chyroc.cn 的 nginx 配置 原来的 chyroc.cn 是指向我的云主机的，由服务器上面的 nginx 做反向代理，现在需要删除该配置，即移除 server_name chyroc.</description></item><item><title>使用加 1 项目体验 golang 的 wasm</title><link>https://chyroc.cn/posts/use-plus-one-to-experience-golang-wasm/</link><pubDate>Wed, 20 Jun 2018 17:45:48 +0800</pubDate><guid>https://chyroc.cn/posts/use-plus-one-to-experience-golang-wasm/</guid><description>什么是 WebAssembly WebAssembly（以下简称 wasm）是一种新的编码方式，可以在现代的网络浏览器中运行。啥意思，就是除了 JavaScript（以下简称 js），还有一种语言可以在浏览器里面运行了！
对于网络平台而言，WebAssembly 具有巨大的意义——它提供了一条途径，以使得以各种语言编写的代码都可以以接近原生的速度在 Web 中运行。在这种情况下，以前无法以此方式运行的客户端软件都将可以运行在 Web 中。
编译支持 wasm 的 go golang 的 release 版本（1.10）还不支持 wasm，但是在 github.com/golang/go 的 master 分支中已经包含 wasm 了，所以我们需要自己编译一个 go。
git clone http://github.com/golang/go /path/go cd /path/go/src ./make.bash /path/go/bin/目录下会生成编译后的 go：/path/go/bin/go
设置GOROOT为/path/go/
创建自己的 wasm 程序 参见项目：https://github.com/Chyroc/golang-wasm-example
index.html index.html引入了wasm_exec.js（这个是从/path/go/misc/wasm/wasm_exec.js复制来过的）和加载 wasm 的 js（这个参见参见文档），总之这样我们的 wasm 就已经加载到我们的网页了
最后有一个显示数字的 span 块，和两个+和-的 button，我们待会写的 wasm 代码就是操作这个 span 块的
&amp;lt;html&amp;gt; &amp;lt;head&amp;gt; &amp;lt;title&amp;gt;加1减1&amp;lt;/title&amp;gt; &amp;lt;script src=&amp;quot;wasm_exec.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt; &amp;lt;script type=&amp;quot;text/javascript&amp;quot;&amp;gt; function fetchAndInstantiate(url, importObject) { return fetch(url).</description></item><item><title>go 中的自动测试</title><link>https://chyroc.cn/posts/go-auto-test/</link><pubDate>Fri, 18 May 2018 08:00:00 +0800</pubDate><guid>https://chyroc.cn/posts/go-auto-test/</guid><description>前言 最近在做 leetcode 的题目，需要搞一些简单的测试代码，但是测试函数的输入输出的描述、判断函数是否成功比较麻烦
所以我就在想，能不能我定义一个 input 和一个 output，能够自动的将 input 转成 go 的代码，然后执行测试函数之后，比较返回值和 output 是否一致
要想这么做，肯定需要使用到反射，并且需要定义一下怎么从字符串转化到 go 的代码
parse 字符串定义 用逗号分隔数组的各个元素 用\n分隔多个输入或者多个输出 [1,2,3] 定义 slice {a: b} 定义 map slice 或者 map 中的子元素的类型要看函数定义参数的类型 代码解析 parseParam 这里需要自定义 string 转化 参数是string / reflect.Type，返回值是reflect.Value
主要是tring to int,bool,slice,map，并转成reflect.Value的类型
func parseParam(t *testing.T, param string, typ reflect.Type) reflect.Value { var r reflect.Value var as = assert.New(t) param = strings.TrimSpace(param) switch typ.Kind() { case reflect.Int: i, err := strconv.</description></item><item><title>gopkg.in/validator.v2 源码阅读</title><link>https://chyroc.cn/posts/source-validator-v2/</link><pubDate>Fri, 18 May 2018 08:00:00 +0800</pubDate><guid>https://chyroc.cn/posts/source-validator-v2/</guid><description>说明 本篇文章是 go 的验证器 gopkg.in/validator.v2 的阅读笔记，源码地址是 https://github.com/go-validator/validator 。
这个包怎么用的 type NewUserRequest struct { Username string `validate:&amp;quot;min=3,max=40,regexp=^[a-zA-Z]*$&amp;quot;` Name string `validate:&amp;quot;nonzero&amp;quot;` Age int `validate:&amp;quot;min=21&amp;quot;` Password string `validate:&amp;quot;min=8&amp;quot;` } nur := NewUserRequest{Username: &amp;quot;something&amp;quot;, Age: 20} if errs := validator.Validate(nur); errs != nil { // values not valid, deal with errors here } 使用validate作为 tag 的名字，然后以逗号分隔验证逻辑，然后对于这样的 struct 值，调用validator.Validate(nur)验证
本包有 6 个内置的验证函数，并且可以手动添加自定义的验证函数，具体有哪些我们待会再代码详解的时候再说。
总之，我们在定义 struct 的时候可以使用validate作为 tag 的名字添加一些验证规则，然后使用validator.Validate(nur)验证数据是否满足我们定义的规则，如果不满足的话，就会返回 err
里面的逻辑是啥 显然第一步就是，使用reflect将每个 field 的 tag 取出来，我们规定你必须使用 validate 作为 tag 的名字，这样我们就能拿到规则了</description></item><item><title>golang 中的 testing 包介绍</title><link>https://chyroc.cn/posts/go-test-introduction/</link><pubDate>Tue, 15 May 2018 08:00:00 +0800</pubDate><guid>https://chyroc.cn/posts/go-test-introduction/</guid><description>testing 包是 go 中提供自动化测试的包，和命令 go test 配合使用，能够自动执行匹配到的函数。
TestXxx 测试函数一般是这样的：
func TestXxx(*testing.T) 测试函数需要满足一定的条件才能被执行，就像上面的那样，以Test开头，然后接一个以大写字母开头的单词，函数参数是*testing.T
测试函数所在的文件也需要满足一定的条件：文件名需要以_test.go结尾，这样的文件在go build的时候不会包含，但是可以在go test的时候调用到
BenchmarkXxx 其实还有一种测试函数：
func BenchmarkXxx(*testing.B) 和上面那个TestXxx差不多，以Benchmark开头，并接一个大写字母开头的单词，函数参数是*testing.B
这样的测试函数是压力测试函数，可以使用go test并且加上-bench参数的时候，被调用到
测试用例：
func BenchmarkHello(b *testing.B) { for i := 0; i &amp;lt; b.N; i++ { fmt.Sprintf(&amp;quot;hello&amp;quot;) } } 压力测试函数必须运行 b.N 次目标代码，在压力测试函数运行期间，b.N 会动态的调整，直到基准测试功能持续足够长时间以可靠地计时为止
压力测试函数的输出类似于：
BenchmarkHello 10000000 282 ns/op 这个的意思是压力测试函数以平均 282ns 每次的速度运行了 10000000 次
如果压力测试函数需要 setup 一些操作，那么需要调用一下b.ResetTimer()，示例：
func BenchmarkBigLen(b *testing.B) { big := NewBig() b.ResetTimer() for i := 0; i &amp;lt; b.</description></item><item><title>Golang 中的 context 之控制（二）</title><link>https://chyroc.cn/posts/golang-context-ii/</link><pubDate>Fri, 04 May 2018 08:00:00 +0800</pubDate><guid>https://chyroc.cn/posts/golang-context-ii/</guid><description>怎么使用 context 控制 goroutine 的 cancel 的 是如何实现流程控制的
context 包除了上面介绍的 k-v 数据对外，还有三个函数，分别是：
context.WithCancel context.WithDeadline context.WithTimeout 这三个函数都会返回一个类型为CancelFunc的函数，通过源码可以知道，这几个函数里面返回的 cancel 分别是
// context.WithCancel // c是cancelCtx func() { c.cancel(true, Canceled) } // context.WithDeadline // c是timerCtx WithCancel(parent) // or func() { c.cancel(true, Canceled) } // context.WithTimeout WithDeadline(parent, time.Now().Add(timeout)) 从这里可以看出来，这三个函数的 cancel 是通过两个结构cancelCtx和timerCtx实现的
cancelCtx:
type cancelCtx struct { Context mu sync.Mutex // protects following fields done chan struct{} // created lazily, closed by first cancel call children map[canceler]struct{} // set to nil by the first cancel call err error // set to non-nil by the first cancel call } timerCtx:(依赖了 cancelCtx)</description></item><item><title>Golang 中的 context 之传值（一）</title><link>https://chyroc.cn/posts/golang-context-i/</link><pubDate>Sun, 29 Apr 2018 08:00:00 +0800</pubDate><guid>https://chyroc.cn/posts/golang-context-i/</guid><description>前几天在工作中使用 context 的时候，对于 metadata 和 context.Value 有一些疑惑，顺便探索了一下 go 的 context，在这里分享一下
现在是 2018-04-29 19:49，正在北京开往家的动车上，窗外已经是黑黑的一片了，11 点到家，写一会文章吧
context 包 这里说的 context 包指的是 golang(1.7+)中的标准库 context，文档在这里：https://godoc.org/context 。
context 包定义了 Context 类型，他可以在携带 deadlines 和 cancelatin 信号，也可以携带其他的请求值。
发送到 server 的请求应该创建一个 context，服务器处理请求的时候也应该接受一个 context。在程序的函数调用链中，必须传递 context，也可以基于一个 context，使用 WithCancel, WithDeadline, WithTimeout, or WithValue 等函数创建一个新的 context 传递下去。当一个 context 被 canceled 的时候，那么所有通过改 context 派生的 context 都应该被 cancel
WithCancel, WithDeadline, and WithTimeout 这三个函数使用一个 context(the parent) 作为参数，然后创建一个新的 context（the child）和 CancelFunc 函数。调用 CancelFunc 函数将会取消该 child 和他的 children，移除 parent 到 child 的应用，然后停止任何相关的 timeers。吐过调用这个函数失败的话，会导致 child 和他的 children 知道 parent cancel 的时候或者 timer fired 的时候才会取消。go vet 工具会检查 CancelFuncs 对否在所有的控制分支上使用了。</description></item><item><title>Token、认证与授权</title><link>https://chyroc.cn/posts/token-token-authentication-authorization/</link><pubDate>Sun, 08 Apr 2018 08:00:00 +0800</pubDate><guid>https://chyroc.cn/posts/token-token-authentication-authorization/</guid><description>这篇文章是我在公司内部分享的 paper（去掉了敏感信息之后），在这里贴一下~
什么是认证和授权 有哪些方式 我们是怎么设计的 认证和授权 认证 authentication 授权 authorization ~~X~~ ~~√~~ X X √ X √ √ 公开的数据/可以匿名访问的
验证有效的 user
需要 ACL 系统验证 有哪些方式 Cookie 与 Session
Basic Auth
JWT
OAuth2 Cookie 与 Session Cookie：键值对；Set-Cookie
Session：浏览器存储 cookie，包含 session-id；服务端验证 session-id 有效性，并获取 user 信息
优点：简单</description></item><item><title>日常开发中使用的工具</title><link>https://chyroc.cn/posts/dev-tools/</link><pubDate>Mon, 26 Mar 2018 08:00:00 +0800</pubDate><guid>https://chyroc.cn/posts/dev-tools/</guid><description> 在日常开发中会使用到一些工具，这些工具大大提高了我开发的效率，所以在这里逐个记录下他们，以及他们使用的技巧。
并且有的时候，某些工具的使用方式可能会有些遗忘，那么本系列文章也将作为我以后使用时候的查缺补漏。
list jq todo https://github.com/hit9/img2txt jetbrain ide pbpaste curl grep, tail, cat, less j git, alias</description></item><item><title>anko 源代码阅读之 lex 文件阅读（三）</title><link>https://chyroc.cn/posts/anko-iii/</link><pubDate>Fri, 23 Mar 2018 08:00:00 +0800</pubDate><guid>https://chyroc.cn/posts/anko-iii/</guid><description>这篇文章是在阅读GitHub - mattn/anko: Scriptable interpreter written in golang时候的笔记
diff --git parser/lexer.go parser/lexer.go // Package parser implements parser for anko. package parser import ( &amp;quot;errors&amp;quot; &amp;quot;fmt&amp;quot; &amp;quot;unicode&amp;quot; &amp;quot;github.com/mattn/anko/ast&amp;quot; ) const ( // EOF is short for End of file. + // 文件的末尾 EOF = -1 + // 行的末尾 // EOL is short for End of line. EOL = &#39;\n&#39; ) // Error provides a convenient interface for handling runtime error.</description></item><item><title>anko 源代码阅读之 go 的 lex/yacc（二）</title><link>https://chyroc.cn/posts/anko-ii/</link><pubDate>Wed, 21 Mar 2018 08:00:00 +0800</pubDate><guid>https://chyroc.cn/posts/anko-ii/</guid><description>这篇文章是在阅读GitHub - mattn/anko: Scriptable interpreter written in golang时候的笔记
yacc 的语法 结构，由%%分割的三部分组成：声明 %% 规则 %% 程序 %{与%}之间的代码将会直接出现在目标代码中 yacc 命令忽略语法文件中的空格、制表符和换行符 注释：/* This is a comment on a line by itself. */ 使用&#39;&#39;（单引号）表示字符串 优先顺序规则由 %prec 关键字定义，并更改与特定的语法规则关联的优先顺序级别。保留符号 %prec 可紧跟在语法规则的主体后面，且其后可有标记名称或者文字。构造使得语法规则的优先顺序成为标记名称或者文字的优先顺序。 其他语法请阅读下面的注释 go 的 yacc 工具 安装 go get -u golang.org/x/tools/cmd/goyacc 使用 goyacc -o parse.go parse.y 使用上面的工具和命令会生成一个parse.go文件
编写 lex 文件 为了用上这个文件，我们需要实现yyLexer接口
type yyLexer interface { Lex(lval *yySymType) int Error(s string) } Lex 函数要求返回 token 的值</description></item><item><title>anko 源代码阅读之整体结构（一）</title><link>https://chyroc.cn/posts/anko-i/</link><pubDate>Tue, 20 Mar 2018 08:00:00 +0800</pubDate><guid>https://chyroc.cn/posts/anko-i/</guid><description>今天查资料的时候看见一句话：「我写博客的习惯，一直都在假想一个小白看我的文章，要怎么样才能说得让他看完我的博客就能明白我讲解的知识点。」，觉得对于我写文章具有指导性的意见，在这里记录下来。
这篇文章是在阅读GitHub - mattn/anko: Scriptable interpreter written in golang时候的笔记
anko GitHub - mattn/anko: Scriptable interpreter written in golang是一个语法类似于 go，并且使用 go 作为引擎执行的脚本语言。
公司目前使用的最常见的语言是 go，在某些业务（如：提供用户在某些条件下触发 trigger 的能力）下，需要执行一些用户的脚本，这个时候，我们就用到了 anko。
但是有几处地方使用到了 anko，大家对于 anko 不断的重复封装，所以决定在公司内部封装一套含有我们内部 API 的 anko。
我可能会涉及到这部分业务代码的编写和 review，所以看了一下 anko 的源代码，这也是本篇文章的由来（如果有下一篇文章，那么也是本系列文章的由来。
注意：本代码阅读，截止 commit：https://github.com/mattn/anko/commit/45d93882b6a0a4a02bd31a9265d325c44a8a4964 。
我的疑问 我以前没有接触过编译器相关，一直有一个疑问：如何识别代码 import 如何处理 import 的包和定义的函数怎么就调用到了 代码结构 anko 代码里面有一些包，本节要讲的是：
ast // 抽象语法树结构 parser // 解析脚本字符串，生成抽象语法树 vm // 执行脚本 其他的暂时忽略掉
解析脚本，生成抽象语法树 代码参见：https://github.com/mattn/anko/blob/45d93882b6a0a4a02bd31a9265d325c44a8a4964/parser/lexer.go#L518
解析脚本的入口
import &amp;quot;github.com/mattn/anko/ast&amp;quot; func ParseSrc(src string) ([]ast.</description></item><item><title>gopher-reading-list 阅读笔记</title><link>https://chyroc.cn/posts/read-gopher-reading-list/</link><pubDate>Tue, 06 Mar 2018 08:00:00 +0800</pubDate><guid>https://chyroc.cn/posts/read-gopher-reading-list/</guid><description>GitHub - cdarwin/go-koans: koans for go阅读有感 package go_koans import ( &amp;quot;testing&amp;quot; &amp;quot;fmt&amp;quot; ) func TestNote(t *testing.T) { // basic { assert(5^2 == 7) // 乘方是：math.Pow()，这个是按位与 } // string { assert(&amp;quot;abc&amp;quot;[0] == uint8(&#39;a&#39;)) assert(fmt.Sprintf(&amp;quot;hello %q&amp;quot;, &amp;quot;world&amp;quot;) == &amp;quot;hello \&amp;quot;world\&amp;quot;&amp;quot;) assert(fmt.Sprintf(&amp;quot;your balance: %d and %0.2f&amp;quot;, 3, 4.5589) == &amp;quot;your balance: 3 and 4.56&amp;quot;) // %q 会加上双引号 // %0.2f 会四舍五入 } // array alice { assert(cap([4]string{&amp;quot;apple&amp;quot;, &amp;quot;orange&amp;quot;, &amp;quot;mango&amp;quot;}) == 4) // it can hold no more assert(cap([]string{&amp;quot;apple&amp;quot;, &amp;quot;orange&amp;quot;, &amp;quot;mango&amp;quot;}) == 3) // it can hold no more // array slice在计算cap的不同 f := []string{&amp;quot;apple&amp;quot;, &amp;quot;orange&amp;quot;, &amp;quot;mango&amp;quot;} f[0] = &amp;quot;change&amp;quot; assert(f[0] == &amp;quot;change&amp;quot;) // slice会引用计算 p := []string{&amp;quot;baby&amp;quot;, &amp;quot;baby&amp;quot;, &amp;quot;lemon&amp;quot;} assert(cap(p) == 3) p = append(p, &amp;quot;baby!</description></item><item><title>defer 与 panic 的问题（defer 之二）</title><link>https://chyroc.cn/posts/defer-panic/</link><pubDate>Thu, 25 Jan 2018 08:00:00 +0800</pubDate><guid>https://chyroc.cn/posts/defer-panic/</guid><description>defer 与 panic 问题
package main func f1() { defer println(&amp;quot;f1-begin&amp;quot;) f2() defer println(&amp;quot;f1-end&amp;quot;) } func f2() { defer println(&amp;quot;f2-begin&amp;quot;) f3() defer println(&amp;quot;f2-end&amp;quot;) } func f3() { defer println(&amp;quot;f3-begin&amp;quot;) panic(0) defer println(&amp;quot;f3-end&amp;quot;) } func main() { f1() } 最后 f3 中 panic，所以 defer 不再增加，defer 栈是：f11 f21 f31 panic
第二个问题
package main import &amp;quot;log&amp;quot; func f() { defer func() { if r := recover(); r != nil { log.Printf(&amp;quot;recover:%#v&amp;quot;, r) } }() panic(1) panic(2) } func main() { f() } 两个 panic 的时候 recover，结果是什么：</description></item><item><title>defer 与 return 的问题（defer 之一）</title><link>https://chyroc.cn/posts/defer-return/</link><pubDate>Thu, 25 Jan 2018 08:00:00 +0800</pubDate><guid>https://chyroc.cn/posts/defer-return/</guid><description>我们知道 defer 的时候会将后面的函数入栈，然后 return 的时候执行。
那么具体是什么样子的呢。
分 4 步：
- 遇到defer函数，计算defer函数的参数值，入栈 - 将return后面的值计算出来，赋给t（这个t是函数声明中要返回的的变量） - 执行defer函数 - 空的return（结果就是那个t） 关于 defer 函数的参数什么时候计算 package main import ( &amp;quot;fmt&amp;quot; &amp;quot;time&amp;quot; ) func main() { defer fmt.Println(time.Now()) // 1 time.Sleep(time.Second) fmt.Println(time.Now()) // 3 } 先 print 的时间(line 3)是要比后 print 的时间(line 1)多 1s 的，所以是先计算 defer 的参数，入栈，然后再继续往下执行
关于 return 后面的参数与 defer 函数之间的关系 最重要的一点就是要明白，return xxx 这一条语句并不是一条原子指令!
下面这段代码给了三个使用了 defer 的函数f_x()，然后将其分解开了，写成了g_x()，希望通过这个分解让你对 defer 更加了解。
package main import &amp;quot;sync&amp;quot; func f1() (result int) { defer func() { result++ }() return 0 } func g1() (result int) { result = 0 // 1 result++ // 2 return // 3 } func f2() (r int) { t := 5 defer func() { t = t + 5 }() return t } func g2() (r int) { t := 5 r = t // 1 t = t + 5 // 2 return // 3 } func f3() (r int) { defer func(r int) { r = r + 5 }(r) return 1 } func g3() (r int) { r = 1 // 1 var s = sync.</description></item><item><title>for 循环中 index 指针与变量作用域的问题</title><link>https://chyroc.cn/posts/index-pointer-and-variable-scope-in-a-for-loop/</link><pubDate>Thu, 25 Jan 2018 08:00:00 +0800</pubDate><guid>https://chyroc.cn/posts/index-pointer-and-variable-scope-in-a-for-loop/</guid><description>package main const N = 3 func main() { m := make(map[int]*int) for i := 0; i &amp;lt; N; i++ { m[i] = &amp;amp;i //A } for _, v := range m { print(*v) } } 结果是
333 原因是 - 循环的 k,v 的地址在循环的时候是不变的 - 循环内声明的变量，每次都是不一样的 - 存 k 和 v 的地址并不会计算出来然后存起来，而是存的「k 和 v 的地址」这个概念，所以最后所有的值指向的都是最后一次循环的地址
所以重点就是 i 每次都是那个 i，p 每次都不是那个 p（作用域知识）
所以需要在循环内部申请局部变量存 i，然后把他的地址赋给 map
package main const N = 3 func main() { m := make(map[int]*int) for i := 0; i &amp;lt; N; i++ { p := i m[i] = &amp;amp;p //A } for _, v := range m { print(*v) } } 参考 https://github.</description></item><item><title>interface 与 nil 的比较</title><link>https://chyroc.cn/posts/interface-and-nil-comparison/</link><pubDate>Thu, 25 Jan 2018 08:00:00 +0800</pubDate><guid>https://chyroc.cn/posts/interface-and-nil-comparison/</guid><description>package main type S struct{} func (s S) F() {} type IF interface { F() } func InitType() S { var s S return s } func InitPointer() *S { var s *S return s } func InitEfaceType() interface{} { var s S return s } func InitEfacePointer() interface{} { var s *S return s } func InitIfaceType() IF { var s S return s } func InitIfacePointer() IF { var s *S return s } func main() { //println(InitType() == nil) println(InitPointer() == nil) println(InitEfaceType() == nil) println(InitEfacePointer() == nil) println(InitIfaceType() == nil) println(InitIfacePointer() == nil) } 结果是</description></item><item><title>slice 与底层数组引用</title><link>https://chyroc.cn/posts/subslice-grow/</link><pubDate>Thu, 25 Jan 2018 08:00:00 +0800</pubDate><guid>https://chyroc.cn/posts/subslice-grow/</guid><description>package main import ( &amp;quot;fmt&amp;quot; ) func main() { s := []int{1, 2, 3} ss := s[1:] for i := range ss { ss[i] += 10 } fmt.Println(s) ss = append(ss, 4) for i := range ss { ss[i] += 10 } fmt.Println(s) } 结果是
[1 12 13] [1 12 13] 也就是说第一个循环改变了 s，第二个循环没有改变。
为什么会这样呢，因为在第一个循环中，s 和 ss 都是 slice，底层共用的是一个数组，所以改变 ss 的时候，实际上改变的是底层的数组，所以 s 也会跟着改变。
在第二个循环中，ss = append(ss, 4)这句话会将 ss 底层引用的数组改变，所以从这里开始 s 和 ss 就没有关联了。所以改变 ss 的时候，并不会改变 s。</description></item><item><title>tiedot 阅读笔记（一）</title><link>https://chyroc.cn/posts/source-tiedot-i/</link><pubDate>Mon, 22 Jan 2018 08:00:00 +0800</pubDate><guid>https://chyroc.cn/posts/source-tiedot-i/</guid><description>tiedot Tiedot 是一个完全使用 go 实现的文档型的 NoSQL，项目地址是：GitHub - HouzuoGuo/tiedot
项目结构 使用命令tree -L 1查看目录结构：
. ├── Dockerfile ├── LICENSE ├── README.md ├── benchmark ├── data ├── db ├── dberr ├── distributable ├── doc ├── docker-compose.yml ├── examples ├── extra ├── gommap ├── httpapi ├── main.go ├── tdlog ├── test-and-coverage-report.sh └── vendor 如何存储数据 文件结构与条件编译 存储数据的代码全部在 data 里面，这篇文章先只关注这个 tree data | grep -v &#39;_test.go&#39; 数据：
data ├── collection.go ├── collection32.go ├── collection64.go ├── config.</description></item><item><title>异步与函数引用外部变量的问题</title><link>https://chyroc.cn/posts/async-function-references-to-external-variables/</link><pubDate>Wed, 13 Dec 2017 16:27:56 +0800</pubDate><guid>https://chyroc.cn/posts/async-function-references-to-external-variables/</guid><description>原因就是因为是异步的，循环会首先执行结束，再去执行函数
如果循环次数比较少的话，那么函数所引用的外部变量就会变成最后一个值，在函数f1中，就是全部是c
所以可以想象的是，如果循环特别多的话，那么会有一部分函数引用的变量是一样的，结果就是输出很多个 x，再输出很多个 x+1&amp;hellip;，如函数f3
解决这个问题的方法就是，不要在函数内部直接引用外部变量，而是显式的传递参数，如函数f2
package main import ( &amp;quot;fmt&amp;quot; &amp;quot;sync&amp;quot; ) func f1() { wg := sync.WaitGroup{} wg.Add(3) s := []string{&amp;quot;a&amp;quot;, &amp;quot;b&amp;quot;, &amp;quot;c&amp;quot;} for _, i := range s { go func() { fmt.Printf(&amp;quot;%s\n&amp;quot;, i) // &amp;lt;--- 打印的都是c，也就是打印了3个c wg.Done() }() } wg.Wait() } func f2() { wg := sync.WaitGroup{} wg.Add(3) s := []string{&amp;quot;a&amp;quot;, &amp;quot;b&amp;quot;, &amp;quot;c&amp;quot;} for _, i := range s { go func(t string) { fmt.Printf(&amp;quot;%s\n&amp;quot;, t) // &amp;lt;--- a, b, c wg.</description></item><item><title>走过的路和写过的代码</title><link>https://chyroc.cn/posts/2017-year-end-summary/</link><pubDate>Wed, 13 Dec 2017 16:25:57 +0800</pubDate><guid>https://chyroc.cn/posts/2017-year-end-summary/</guid><description>人生很长，又很短，今天我们在一起把酒言欢，但是不知道什么时候就不再相见了。
谨以此文献给我的 2017。
2017 是我在北京的第一年，也是我工作的第一年，也是我开心写代码的第一年，也是我一个人生活的第一年。
刚来到北京的时候，天气很干燥，嗓子很干，总是要喝很多水才行。不过北京的冬天也是要比南方幸福很多，足足的暖气让我可以在室内穿着夏装写代码，真是一件幸福的事情。
楼底下的北京大爷养了全小区的鸟，还有鸽子。和电视剧里面的老北京形象渐渐重合，中国的首都。
有时候加班，做地铁的时候就没有多少人（后来搬家了没有机会坐地铁了） 在北京遇到的第一场雪 4 月份的时候去了一趟天津，和小杜会师 mada 写过的代码 大家散伙以后，去了重庆-成都-九寨沟一趟 那段闲适的时光，去了次故宫 休息了一段时间之后来到 meiqia 开始新的代码征程（带走了甲鱼的坐骑
老大说我做的不错，还是很开心的，不过内功有待加强。 新的敲代码的地方离市中心很远 来北京找我的人和我去找的人（无 年末的时候过的迈入「中年人」的生日 北京很大，从北边到南边要几个小时，北京又很小，我就在那，我的小窝里。
我的 2018 即将到来。</description></item><item><title>man 命令添加高亮</title><link>https://chyroc.cn/posts/man-command-highlight/</link><pubDate>Tue, 08 Aug 2017 16:37:36 +0800</pubDate><guid>https://chyroc.cn/posts/man-command-highlight/</guid><description>添加下列配置到~/.zshrc
man() { env GROFF_NO_SGR=1 \ LESS_TERMCAP_mb=$&#39;\E[1;36m&#39; \ LESS_TERMCAP_md=$&#39;\E[1;36m&#39; \ LESS_TERMCAP_me=$&#39;\E[0m&#39; \ LESS_TERMCAP_se=$&#39;\E[0m&#39; \ LESS_TERMCAP_so=$&#39;\E[1;44;33m&#39; \ LESS_TERMCAP_ue=$&#39;\E[0m&#39; \ LESS_TERMCAP_us=$&#39;\E[1;33m&#39; \ man &amp;quot;$@&amp;quot; }</description></item><item><title>最大子序列和问题</title><link>https://chyroc.cn/posts/algorithms-largest-subsequences/</link><pubDate>Mon, 07 Aug 2017 16:39:11 +0800</pubDate><guid>https://chyroc.cn/posts/algorithms-largest-subsequences/</guid><description>最大子序列和问题 问题 最大子序列和问题：
给定整数$A_1$,$A_2$,&amp;hellip;,$A_n$（可能有负数），求$ \sum{^j_{k=i}}A_k$的最大值
（为方便起见，如果所有整数都是负数，则明天子序列和为 0）
四个算法和时间复杂度 算法 时间复杂度 算法一 $O(N^3)$ 算法二 $O(N^2)$ 算法三 $O(NlogN)$ 算法四 $O(N)$ 算法一 三重循环。
前两个循环是列出所有可能的子序列，i, j分别指向子序列的头和尾。
第三个循环是对子序列进行求和。
func function1(a []int) int { n := len(a) maxSum := 0 for i := 0; i &amp;lt; n; i++ { for j := i; j &amp;lt; n; j++ { tempSum := 0 for k := i; k &amp;lt;= j; k++ { tempSum += a[k] } if tempSum &amp;gt; maxSum { maxSum = tempSum } } } return maxSum } 算法二 和算法一相比，将第二个循环和第三个循环合并。也就是说不用再特地循环一遍子数组，在第二次循环的时候已经计算了子数组的最大值。 从这个角度去看的话，算法一实际上对一些已经计算的并且待会还要用到的数据进行了丢失。</description></item><item><title>golang 的 interface(第二篇) - 接口的作用</title><link>https://chyroc.cn/posts/golang-interface-ii/</link><pubDate>Fri, 04 Aug 2017 16:40:04 +0800</pubDate><guid>https://chyroc.cn/posts/golang-interface-ii/</guid><description>在golang 的 interface(第一篇) - 接口的定义与实现里面，我稍微讲了一下我理解的什么是接口，怎么定义接口，怎么实现接口，本文将会讲一讲接口的作用。
接口作为参数代表什么 如果一个函数的参数类型是一个接口，代表：在使用这个函数的时候，可以传进来一个实现了这个接口的类型。
比如一个接口的参数类型是「跑」(runType)，不管他是跑到哪里，跑多久，是要一个对象可以跑，那这个对象就可以使用这个函数。
接口作为参数可以做什么 将对象一般行为抽象出来，作为接口，例如：
io.Writer
type Writer interface { Write(p []byte) (n int, err error) } 代表了所有可以写入字节的抽象，比如：文件，缓冲，http，hasher。
只要一个类型实现了io.Writer接口，那他就可以去写。（具体怎么写在这个接口实现的方法里详细定义了。）
我觉得自己对这个还不理解，感觉自己说了很多废话。
现在有一个方法，输入一些字节和一个对象，就会调用这个对象的写方法，叫做Print。
所以，屏幕可以定义自己的展现字符的方式，日志可以定义自己存储日志的格式，http server 可以定义网络返回的数据的格式，等等等等，只要这个独特的对象定义了自己的写方法，那么他就可以药药药切克闹。。
sort 包示例说明 在 golang 内置的 sort 包里面，定义了一个Interface：
type Interface interface { Len() int Less(i, j int) bool Swap(i, j int) } 好奇怪，竟然名字就是叫做Interface。
然后还定义了一个函数，接受作为参数，并将其排序
func Sort(data Interface) 所以，对于任何数据类型，你定义的乱七八糟的东西。你想要对他排序？
没问题，只要你去为这个数据类型实现Interface的接口
字符串数组 sort 示例 type personName []string func (pn personName) Len() int { return len(pn) } func (pn personName) Less(i, j int) bool { return pn[i] &amp;lt; pn[j] } func (pn personName) Swap(i, j int) { pn[i], pn[j] = pn[j], pn[i] } 上面先定义了一个字符串数组personName，然后实现了sort包里面的Interface接口，所以可以用sort.</description></item><item><title>golang 的 interface(第一篇) - 接口的定义与实现</title><link>https://chyroc.cn/posts/golang-interface-i/</link><pubDate>Thu, 03 Aug 2017 16:40:48 +0800</pubDate><guid>https://chyroc.cn/posts/golang-interface-i/</guid><description>golang 有哪些数据类型 interface 是一种数据类型吗，答案是：是。
golang 语言有四种数据类型，分别是 - 基本类型(basic) - 数字 - 字符串 - 布尔型 - 聚合类型(aggregate) - 数组 - struct - 复合类型(reference) - 指针 - slice - map - 函数 - channel - 接口类型(interface)
什么是方法 方法是定义在一个数据类型上面的函数，可以类比为 “面向对象中，类中的方法”。
方法和这个数据类型需要处于同一个包里，所以对于内置类型，如 int，需要从他定义一个数据类型，
type CountNum int 然后再在这个新的数据类型上定义方法
func (c CountNum) Print { fmt.Printf(&amp;quot;CountNum is %d&amp;quot;, i) } 最常用的就是在 struct 上定义方法
type Person struct { Name string Age int } func (p Person) Get { return fmt.</description></item><item><title>int16 溢出 bug 记录</title><link>https://chyroc.cn/posts/int16-overflow-bug-record/</link><pubDate>Mon, 31 Jul 2017 16:48:30 +0800</pubDate><guid>https://chyroc.cn/posts/int16-overflow-bug-record/</guid><description>在一个业务中用到了 token（介绍参见这里）
加密：将各种信息+生成时间(issueTime)+有效期(ttl)利用私钥加密，然后 base64。
判断过期的时候，会首先去检查 token 里面编码的 issueTime+ttl，和time.now对比。
但是呢，为了减少 token 的长度，ttl是 int16 类型的（单位分钟），所以最大存储 32768。而我们需要存储一星期的 token，也就是 7*24*60 = 10080。
哈哈，本来是没有问题的，bug 就是出现在下面一点。
计算过期：
if issueTime + uint32(ttl*60) &amp;lt; time.Now().Unix() { // 过期 } 我刚开始是认为 ttl 虽然是 int16 的，但是外面包了一层 uint32，所以结果没什么问题。可是ttl*60的结果直接就溢出了，所以就算外面包了一层，也没有任何影响。最终的结果还是溢出。。
改进：
if issueTime + uint32(ttl)*60 &amp;lt; time.Now().Unix() { // 过期 } bug 记录。</description></item><item><title>mongodb 的 ObjectId</title><link>https://chyroc.cn/posts/mongo-object-id/</link><pubDate>Tue, 18 Jul 2017 16:50:57 +0800</pubDate><guid>https://chyroc.cn/posts/mongo-object-id/</guid><description>官方文档解释 ObjectId(&amp;lt;hexadecimal&amp;gt;)
这是一个 12 字节（12-byte）的 ObjectId，其中包括：
4 字节的 unix 秒级时间戳（即 10 位的时间戳）, 3 字节的机器代码, 2 字节的进程代码 3 自己的计数器（从一个随机数开始） 可选参数：
Field Type Description hexadecimal String 可选，16 进制字符串 ObjectId() 有以下属性和方法:
Attribute/Method Description str 返回这个 id 的 16 进制表示的字符串 ObjectId.getTimestamp() 返回这个 id 编码的时间戳 ObjectId.toString() 返回字符串： ObjectId(...) ObjectId.valueOf() 就是 属性 str返回的那个，一样的 解释一个真实的 id 596cee8fd68096396dc0390b 时间戳 一个秒级的时间戳是 10 位十进制数的，如果采用无符号表示方法，那么 n 位二进制（n 个 bit）可以表示的最大数字是 2^n-1，现在需要表示秒级时间戳，就需要 m bit 的空间，也就是：</description></item><item><title>关于</title><link>https://chyroc.cn/about/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://chyroc.cn/about/</guid><description>关于我 /wb:follow-button
本科专业是飞行器动力工程，因缘际会开始写代码。
目前正耕耘于 golang，并充实内功。
写的代码 个人项目和开源贡献统计 基于搜狗微信搜索的微信公众号爬虫接口 展示在 leetcode 上做题的进度的徽标 / Show the progress badge on the leetcode access phpmyadmin from cli / 通过 shell 操作 phpmyadmin list self github contribution / 开源项目贡献统计工具 用 golang 实现的简单 web 路由框架 pics to gif / 照片转 gif 动图 关于本博客 博客的生成管理：hugo 博客主题：hugo-xmin 基于 Issue 的博客评论系统：gitment 知乎账户卡片：zhihu-card GitHub 账户卡片：github-cards 支持我 我的 BTC 地址：19NA8sDf5ZR9VUFBBaTvyVurCYCpXZLhBy</description></item><item><title>友链</title><link>https://chyroc.cn/blogroll/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://chyroc.cn/blogroll/</guid><description> laike9m&amp;rsquo;s blog 白鹤</description></item></channel></rss>